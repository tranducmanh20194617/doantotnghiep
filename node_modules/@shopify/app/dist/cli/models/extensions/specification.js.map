{"version":3,"file":"specification.js","sourceRoot":"","sources":["../../../../src/cli/models/extensions/specification.ts"],"names":[],"mappings":"AAAA,OAAO,EAAgC,UAAU,EAAC,MAAM,cAAc,CAAA;AAGtE,OAAO,EAAC,MAAM,EAAC,MAAM,oBAAoB,CAAA;AAIzC,OAAO,EAAC,UAAU,EAAC,MAAM,gCAAgC,CAAA;AACzD,OAAO,EAAC,GAAG,EAAC,MAAM,8BAA8B,CAAA;AAChD,OAAO,EAAC,YAAY,EAAE,YAAY,EAAC,MAAM,gCAAgC,CAAA;AAiFzE;;;;;;;;;;;;;;;;;;GAkBG;AACH,MAAM,UAAU,4BAA4B,CAC1C,IAA6C;IAE7C,MAAM,QAAQ,GAAG;QACf,2FAA2F;QAC3F,qDAAqD;QACrD,kBAAkB,EAAE,GAAG,IAAI,CAAC,UAAU,WAAW;QACjD,qBAAqB,EAAE,EAAE;QACzB,YAAY,EAAE,UAAU,CAAC,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,IAAI,EAAE,GAAG,CAAC,CAAC;QAC5D,OAAO,EAAE,cAAc;QACvB,qBAAqB,EAAE,IAAI,CAAC,UAAU;QACtC,MAAM,EAAE,UAA2C;QACnD,iBAAiB,EAAE,MAAM,CAAC,UAAU,CAAC,wBAAwB;QAC7D,SAAS,EAAE,IAAI,CAAC,SAAS;QACzB,gBAAgB,EAAE,IAAI,CAAC,gBAAgB;QACvC,QAAQ,EAAE,IAAI,CAAC,QAAQ;QACvB,UAAU,EAAE,IAAI,CAAC,UAAU,IAAI,WAAW;KAC3C,CAAA;IACD,OAAO,EAAC,GAAG,QAAQ,EAAE,GAAG,IAAI,EAAC,CAAA;AAC/B,CAAC;AAED;;;;;;GAMG;AACH,MAAM,UAAU,kCAAkC,CAAyD,IAO1G;IACC,MAAM,iBAAiB,GAAG,IAAI,CAAC,iBAAiB,IAAI,CAAC,GAAG,EAAE,CAAC,EAAE,CAAC,CAAA;IAC9D,OAAO,4BAA4B,CAAC;QAClC,UAAU,EAAE,IAAI,CAAC,UAAU;QAC3B,mHAAmH;QACnH,sFAAsF;QACtF,MAAM,EAAE,IAAI,CAAC,MAAkD;QAC/D,iBAAiB;QACjB,SAAS,EAAE,yBAAyB,CAAC,IAAI,CAAC,eAAe,CAAC;QAC1D,gBAAgB,EAAE,gCAAgC,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,eAAe,CAAC;QACrF,QAAQ,EAAE,wBAAwB,CAAC,IAAI,CAAC,QAAQ,CAAC;QACjD,UAAU,EAAE,eAAe;KAC5B,CAAC,CAAA;AACJ,CAAC;AAED,SAAS,wBAAwB,CAAC,cAA+B;IAC/D,0FAA0F;IAC1F,OAAO,cAAc,EAAE,QAAQ,IAAI,CAAC,CAAC,OAA8B,EAAE,EAAE,CAAC,OAAO,CAAC,CAAA;AAClF,CAAC;AAED,SAAS,yBAAyB,CAAC,eAAmE;IACpG,IAAI,CAAC,eAAe;QAAE,OAAO,CAAC,OAAe,EAAE,EAAE,CAAC,yBAAyB,CAAC,OAAmC,CAAC,CAAA;IAEhH,IAAI,MAAM,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC,QAAQ,CAAC,SAAS,CAAC,EAAE;QACpD,OAAQ,eAA8C,CAAC,OAAQ,CAAA;KAChE;SAAM;QACL,OAAO,CAAC,OAAe,EAAE,EAAE,CAAC,kBAAkB,CAAC,OAAO,EAAE,eAAe,CAAC,CAAA;KACzE;AACH,CAAC;AAED,SAAS,gCAAgC;AACvC,8DAA8D;AAC9D,MAAgC,EAChC,eAAmE;IAEnE,IAAI,CAAC,eAAe;QAClB,OAAO,CAAC,OAAe,EAAE,EAAE,CAAC,gCAAgC,CAAC,MAAM,EAAE,OAAmC,CAAC,CAAA;IAE3G,IAAI,MAAM,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC,QAAQ,CAAC,SAAS,CAAC,EAAE;QACpD,OAAQ,eAA8C,CAAC,OAAQ,CAAA;KAChE;SAAM;QACL,OAAO,CAAC,OAAe,EAAE,EAAE,CAAC,kBAAkB,CAAC,OAAO,EAAE,eAAe,EAAE,IAAI,CAAC,CAAA;KAC/E;AACH,CAAC;AAED;;;;;;;;;;;;;;;;;;;;GAoBG;AAEH,SAAS,kBAAkB,CACzB,OAAe,EACf,MAAyD,EACzD,OAAO,GAAG,KAAK;IAEf,MAAM,kBAAkB,GAAG,EAAE,CAAA;IAE7B,KAAK,MAAM,CAAC,UAAU,EAAE,UAAU,CAAC,IAAI,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,EAAE;QAC7D,MAAM,UAAU,GAAG,OAAO,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,UAAU,CAAA;QACpD,MAAM,UAAU,GAAG,OAAO,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,UAAU,CAAA;QACpD,MAAM,WAAW,GAAG,YAAY,CAAC,OAAO,EAAE,UAAU,CAAC,CAAA;QACrD,IAAI,WAAW,KAAK,SAAS;YAAE,YAAY,CAAC,kBAAkB,EAAE,UAAU,EAAE,WAAW,CAAC,CAAA;KACzF;IAED,OAAO,kBAAkB,CAAA;AAC3B,CAAC;AAED;;;;;;;;;;;;;;;;;;GAkBG;AACH,SAAS,yBAAyB,CAAC,OAAiC;IAClE,OAAO,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,MAAM,CAAC,CAAC,MAAM,EAAE,GAAG,EAAE,EAAE;QACjD,MAAM,gBAAgB,GAAG,OAAO,CAAC,GAAG,CAAC,KAAK,IAAI,IAAI,OAAO,OAAO,CAAC,GAAG,CAAC,KAAK,QAAQ,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,CAAA;QAClH,OAAO,EAAC,GAAG,MAAM,EAAE,GAAG,CAAC,gBAAgB,CAAC,CAAC,CAAC,EAAC,GAAI,OAAO,CAAC,GAAG,CAAY,EAAC,CAAC,CAAC,CAAC,EAAC,CAAC,GAAG,CAAC,EAAE,OAAO,CAAC,GAAG,CAAC,EAAC,CAAC,EAAC,CAAA;IACnG,CAAC,EAAE,EAAE,CAAC,CAAA;AACR,CAAC;AAED;;;;;;;;;;;;;;;;;;GAkBG;AACH,8DAA8D;AAC9D,SAAS,gCAAgC,CAAI,MAAgC,EAAE,OAAiC;IAC9G,OAAO,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,EAAE,CAAC,CAAC,MAAM,CAAC,CAAC,MAAgC,EAAE,GAAW,EAAE,EAAE;QAC/F,IAAI,WAAW,GAAG,MAAM,CAAC,IAAI,CAAC,KAAK,EAAE,CAAC,GAAG,CAAC,CAAA;QAC1C,IAAI,WAAW,YAAY,GAAG,CAAC,WAAW,EAAE;YAC1C,WAAW,GAAG,WAAW,CAAC,IAAI,CAAC,SAAS,CAAA;SACzC;QACD,IAAI,WAAW,YAAY,GAAG,CAAC,SAAS,EAAE;YACxC,MAAM,CAAC,GAAG,CAAC,GAAG,gCAAgC,CAAC,WAAW,EAAE,OAAO,CAAC,CAAA;SACrE;aAAM;YACL,IAAI,OAAO,CAAC,GAAG,CAAC,KAAK,SAAS;gBAAE,MAAM,CAAC,GAAG,CAAC,GAAG,OAAO,CAAC,GAAG,CAAC,CAAA;YAC1D,OAAO,OAAO,CAAC,GAAG,CAAC,CAAA;SACpB;QACD,OAAO,MAAM,CAAA;IACf,CAAC,EAAE,EAAE,CAAC,CAAA;AACR,CAAC","sourcesContent":["import {ZodSchemaType, BaseConfigType, BaseSchema} from './schemas.js'\nimport {ExtensionInstance} from './extension-instance.js'\nimport {SpecsAppConfiguration} from './specifications/types/app_config.js'\nimport {blocks} from '../../constants.js'\n\nimport {Flag} from '../../services/dev/fetch.js'\nimport {Result} from '@shopify/cli-kit/node/result'\nimport {capitalize} from '@shopify/cli-kit/common/string'\nimport {zod} from '@shopify/cli-kit/node/schema'\nimport {getPathValue, setPathValue} from '@shopify/cli-kit/common/object'\n\nexport type ExtensionFeature =\n  | 'ui_preview'\n  | 'function'\n  | 'theme'\n  | 'bundling'\n  | 'cart_url'\n  | 'esbuild'\n  | 'single_js_entry_path'\n\nexport interface TransformationConfig {\n  [key: string]: string\n}\n\nexport interface CustomTransformationConfig {\n  forward?: (obj: object, options?: {flags?: Flag[]}) => object\n  reverse?: (obj: object, options?: {flags?: Flag[]}) => object\n}\n\nexport interface SimplifyConfig {\n  simplify?: (obj: SpecsAppConfiguration) => SpecsAppConfiguration\n}\n\nexport type ExtensionExperience = 'extension' | 'configuration'\n\n/**\n * Extension specification with all the needed properties and methods to load an extension.\n */\nexport interface ExtensionSpecification<TConfiguration extends BaseConfigType = BaseConfigType> {\n  identifier: string\n  externalIdentifier: string\n  externalName: string\n  group?: string\n  additionalIdentifiers: string[]\n  partnersWebIdentifier: string\n  surface: string\n  registrationLimit: number\n  experience: ExtensionExperience\n  dependency?: string\n  graphQLType?: string\n  schema: ZodSchemaType<TConfiguration>\n  getBundleExtensionStdinContent?: (config: TConfiguration) => string\n  deployConfig?: (\n    config: TConfiguration,\n    directory: string,\n    apiKey: string,\n    moduleId?: string,\n  ) => Promise<{[key: string]: unknown} | undefined>\n  validate?: (config: TConfiguration, configPath: string, directory: string) => Promise<Result<unknown, string>>\n  preDeployValidation?: (extension: ExtensionInstance<TConfiguration>) => Promise<void>\n  buildValidation?: (extension: ExtensionInstance<TConfiguration>) => Promise<void>\n  hasExtensionPointTarget?(config: TConfiguration, target: string): boolean\n  appModuleFeatures: (config?: TConfiguration) => ExtensionFeature[]\n  transform?: (content: object) => object\n  reverseTransform?: (content: object, options?: {flags?: Flag[]}) => object\n  simplify?: (remoteConfig: SpecsAppConfiguration) => SpecsAppConfiguration\n}\n\n/**\n * These fields are forbidden when creating a new ExtensionSpec\n * They belong to the ExtensionSpec interface, but the values are obtained from the API\n * and should not be set by us locally\n */\nexport type ForbiddenFields =\n  | 'registrationLimit'\n  | 'category'\n  | 'externalIdentifier'\n  | 'externalName'\n  | 'name'\n  | 'surface'\n\n/**\n * Partial ExtensionSpec type used when creating a new ExtensionSpec, the only mandatory field is the identifier\n */\nexport interface CreateExtensionSpecType<TConfiguration extends BaseConfigType = BaseConfigType>\n  extends Partial<Omit<ExtensionSpecification<TConfiguration>, ForbiddenFields>> {\n  identifier: string\n  appModuleFeatures: (config?: TConfiguration) => ExtensionFeature[]\n}\n\n/**\n * Create a new ui extension spec.\n *\n * Everything but \"identifer\" is optional.\n * ```ts\n * identifier: string // unique identifier for the extension type\n * externalIdentifier: string // identifier used externally (default: same as \"identifier\")\n * partnersWebIdentifier: string // identifier used in the partners web UI (default: same as \"identifier\")\n * surface?: string // surface where the extension is going to be rendered (default: 'unknown')\n * dependency?: {name: string; version: string} // dependency to be added to the extension's package.json\n * graphQLType?: string // GraphQL type of the extension (default: same as \"identifier\")\n * schema?: ZodSchemaType<TConfiguration> // schema used to validate the extension's configuration (default: BaseUIExtensionSchema)\n * getBundleExtensionStdinContent?: (configuration: TConfiguration) => string // function to generate the content of the stdin file used to bundle the extension\n * validate?: (configuration: TConfiguration, directory: string) => Promise<Result<undefined, Error>> // function to validate the extension's configuration\n * preDeployValidation?: (configuration: TConfiguration) => Promise<void> // function to validate the extension's configuration before deploying it\n * deployConfig?: (configuration: TConfiguration, directory: string) => Promise<{[key: string]: unknown}> // function to generate the extensions configuration payload to be deployed\n * hasExtensionPointTarget?: (configuration: TConfiguration, target: string) => boolean // function to determine if the extension has a given extension point target\n * ```\n */\nexport function createExtensionSpecification<TConfiguration extends BaseConfigType = BaseConfigType>(\n  spec: CreateExtensionSpecType<TConfiguration>,\n): ExtensionSpecification<TConfiguration> {\n  const defaults = {\n    // these two fields are going to be overridden by the extension specification API response,\n    // but we need them to have a default value for tests\n    externalIdentifier: `${spec.identifier}_external`,\n    additionalIdentifiers: [],\n    externalName: capitalize(spec.identifier.replace(/_/g, ' ')),\n    surface: 'test-surface',\n    partnersWebIdentifier: spec.identifier,\n    schema: BaseSchema as ZodSchemaType<TConfiguration>,\n    registrationLimit: blocks.extensions.defaultRegistrationLimit,\n    transform: spec.transform,\n    reverseTransform: spec.reverseTransform,\n    simplify: spec.simplify,\n    experience: spec.experience ?? 'extension',\n  }\n  return {...defaults, ...spec}\n}\n\n/**\n * Create a new app config extension spec. This factory method for creating app config extensions is created for two\n * reasons:\n *   - schema needs to be casted to ZodSchemaType<TConfiguration>\n *   - App config extensions have default transform and reverseTransform functions\n\n */\nexport function createConfigExtensionSpecification<TConfiguration extends BaseConfigType = BaseConfigType>(spec: {\n  identifier: string\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  schema: zod.ZodObject<any>\n  appModuleFeatures?: (config?: TConfiguration) => ExtensionFeature[]\n  transformConfig?: TransformationConfig | CustomTransformationConfig\n  simplify?: SimplifyConfig\n}): ExtensionSpecification<TConfiguration> {\n  const appModuleFeatures = spec.appModuleFeatures ?? (() => [])\n  return createExtensionSpecification({\n    identifier: spec.identifier,\n    // This casting is required because `name` and `type` are mandatory for the existing extension spec configurations,\n    // however, app config extensions config content is parsed from the `shopify.app.toml`\n    schema: spec.schema as unknown as ZodSchemaType<TConfiguration>,\n    appModuleFeatures,\n    transform: resolveAppConfigTransform(spec.transformConfig),\n    reverseTransform: resolveReverseAppConfigTransform(spec.schema, spec.transformConfig),\n    simplify: resolveSimplifyAppConfig(spec.simplify),\n    experience: 'configuration',\n  })\n}\n\nfunction resolveSimplifyAppConfig(simplifyConfig?: SimplifyConfig) {\n  // returns the configuration if there is no simplify function defined in the specification\n  return simplifyConfig?.simplify ?? ((content: SpecsAppConfiguration) => content)\n}\n\nfunction resolveAppConfigTransform(transformConfig?: TransformationConfig | CustomTransformationConfig) {\n  if (!transformConfig) return (content: object) => defaultAppConfigTransform(content as {[key: string]: unknown})\n\n  if (Object.keys(transformConfig).includes('forward')) {\n    return (transformConfig as CustomTransformationConfig).forward!\n  } else {\n    return (content: object) => appConfigTransform(content, transformConfig)\n  }\n}\n\nfunction resolveReverseAppConfigTransform<T>(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  schema: zod.ZodType<T, any, any>,\n  transformConfig?: TransformationConfig | CustomTransformationConfig,\n) {\n  if (!transformConfig)\n    return (content: object) => defaultAppConfigReverseTransform(schema, content as {[key: string]: unknown})\n\n  if (Object.keys(transformConfig).includes('reverse')) {\n    return (transformConfig as CustomTransformationConfig).reverse!\n  } else {\n    return (content: object) => appConfigTransform(content, transformConfig, true)\n  }\n}\n\n/**\n * Given an object:\n * ```json\n * { source: { fieldSourceA: 'valueA' } }\n * ```\n *  and a transform config content like this:\n * ```json\n * { 'target.fieldTargetA': 'source.fieldSourceA'}\n * ```\n * the method returns the following object:\n * ```json\n * { source: { fieldTargetA: 'valueA' } }\n * ```\n * The transformation can be applied in both ways depending on the reverse parameter\n *\n * @param content - The objet to be transformed\n * @param config - The transformation config\n * @param reverse - If true, the transformation will be applied in reverse\n *\n * @returns the transformed object\n */\n\nfunction appConfigTransform(\n  content: object,\n  config: TransformationConfig | CustomTransformationConfig,\n  reverse = false,\n): object {\n  const transformedContent = {}\n\n  for (const [mappedPath, objectPath] of Object.entries(config)) {\n    const originPath = reverse ? mappedPath : objectPath\n    const targetPath = reverse ? objectPath : mappedPath\n    const sourceValue = getPathValue(content, originPath)\n    if (sourceValue !== undefined) setPathValue(transformedContent, targetPath, sourceValue)\n  }\n\n  return transformedContent\n}\n\n/**\n * Flat the configuration object to a single level object. This is the schema expected by the server side.\n * ```json\n * {\n *   pos: {\n *    embedded = true\n *   }\n * }\n * ```\n * will be flattened to:\n * ```json\n * {\n *  embedded = true\n * }\n * ```\n * @param content - The objet to be flattened\n *\n * @returns A single level object\n */\nfunction defaultAppConfigTransform(content: {[key: string]: unknown}) {\n  return Object.keys(content).reduce((result, key) => {\n    const isObjectNotArray = content[key] !== null && typeof content[key] === 'object' && !Array.isArray(content[key])\n    return {...result, ...(isObjectNotArray ? {...(content[key] as object)} : {[key]: content[key]})}\n  }, {})\n}\n\n/**\n * Nest the content inside the first level objects expected by the local schema.\n * ```json\n * {\n *  embedded = true\n * }\n * ```\n * will be nested after applying the proper schema:\n * ```json\n * {\n *   pos: {\n *    embedded = true\n *   }\n * }\n * ```\n * @param content - The objet to be nested\n *\n * @returns The nested object\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction defaultAppConfigReverseTransform<T>(schema: zod.ZodType<T, any, any>, content: {[key: string]: unknown}) {\n  return Object.keys(schema._def.shape()).reduce((result: {[key: string]: unknown}, key: string) => {\n    let innerSchema = schema._def.shape()[key]\n    if (innerSchema instanceof zod.ZodOptional) {\n      innerSchema = innerSchema._def.innerType\n    }\n    if (innerSchema instanceof zod.ZodObject) {\n      result[key] = defaultAppConfigReverseTransform(innerSchema, content)\n    } else {\n      if (content[key] !== undefined) result[key] = content[key]\n      delete content[key]\n    }\n    return result\n  }, {})\n}\n"]}