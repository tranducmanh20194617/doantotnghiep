{
  "version": 3,
  "sources": ["../../../node_modules/@apollo/src/react/hooks/useQuery.ts", "../../../node_modules/@apollo/src/react/hooks/useSyncExternalStore.ts", "../../../node_modules/@apollo/src/react/hooks/internal/wrapHook.ts"],
  "sourcesContent": ["import { invariant } from \"../../utilities/globals/index.js\";\n\nimport * as React from \"rehackt\";\nimport { useSyncExternalStore } from \"./useSyncExternalStore.js\";\nimport { equal } from \"@wry/equality\";\n\nimport type {\n  OperationVariables,\n  WatchQueryFetchPolicy,\n} from \"../../core/index.js\";\nimport { mergeOptions } from \"../../utilities/index.js\";\nimport type { ApolloContextValue } from \"../context/index.js\";\nimport { getApolloContext } from \"../context/index.js\";\nimport { ApolloError } from \"../../errors/index.js\";\nimport type {\n  ApolloClient,\n  ApolloQueryResult,\n  ObservableQuery,\n  DocumentNode,\n  TypedDocumentNode,\n  WatchQueryOptions,\n} from \"../../core/index.js\";\nimport { NetworkStatus } from \"../../core/index.js\";\nimport type {\n  QueryHookOptions,\n  QueryResult,\n  ObservableQueryFields,\n  NoInfer,\n} from \"../types/types.js\";\n\nimport { DocumentType, verifyDocumentType } from \"../parser/index.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nimport {\n  canUseWeakMap,\n  compact,\n  isNonEmptyArray,\n  maybeDeepFreeze,\n} from \"../../utilities/index.js\";\nimport { wrapHook } from \"./internal/index.js\";\n\nconst {\n  prototype: { hasOwnProperty },\n} = Object;\n\n/**\n * A hook for executing queries in an Apollo application.\n *\n * To run a query within a React component, call `useQuery` and pass it a GraphQL query document.\n *\n * When your component renders, `useQuery` returns an object from Apollo Client that contains `loading`, `error`, and `data` properties you can use to render your UI.\n *\n * > Refer to the [Queries](https://www.apollographql.com/docs/react/data/queries) section for a more in-depth overview of `useQuery`.\n *\n * @example\n * ```jsx\n * import { gql, useQuery } from '@apollo/client';\n *\n * const GET_GREETING = gql`\n *   query GetGreeting($language: String!) {\n *     greeting(language: $language) {\n *       message\n *     }\n *   }\n * `;\n *\n * function Hello() {\n *   const { loading, error, data } = useQuery(GET_GREETING, {\n *     variables: { language: 'english' },\n *   });\n *   if (loading) return <p>Loading ...</p>;\n *   return <h1>Hello {data.greeting.message}!</h1>;\n * }\n * ```\n * @since 3.0.0\n * @param query - A GraphQL query document parsed into an AST by `gql`.\n * @param options - Options to control how the query is executed.\n * @returns Query result object\n */\nexport function useQuery<\n  TData = any,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: QueryHookOptions<\n    NoInfer<TData>,\n    NoInfer<TVariables>\n  > = Object.create(null)\n): QueryResult<TData, TVariables> {\n  return wrapHook(\n    \"useQuery\",\n    _useQuery,\n    useApolloClient(options && options.client)\n  )(query, options);\n}\n\nfunction _useQuery<\n  TData = any,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: QueryHookOptions<NoInfer<TData>, NoInfer<TVariables>>\n) {\n  return useInternalState(useApolloClient(options.client), query).useQuery(\n    options\n  );\n}\n\nexport function useInternalState<TData, TVariables extends OperationVariables>(\n  client: ApolloClient<any>,\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>\n): InternalState<TData, TVariables> {\n  const stateRef = React.useRef<InternalState<TData, TVariables>>();\n  if (\n    !stateRef.current ||\n    client !== stateRef.current.client ||\n    query !== stateRef.current.query\n  ) {\n    stateRef.current = new InternalState(client, query, stateRef.current);\n  }\n  const state = stateRef.current;\n\n  // By default, InternalState.prototype.forceUpdate is an empty function, but\n  // we replace it here (before anyone has had a chance to see this state yet)\n  // with a function that unconditionally forces an update, using the latest\n  // setTick function. Updating this state by calling state.forceUpdate is the\n  // only way we trigger React component updates (no other useState calls within\n  // the InternalState class).\n  state.forceUpdateState = React.useReducer((tick) => tick + 1, 0)[1];\n\n  return state;\n}\n\nclass InternalState<TData, TVariables extends OperationVariables> {\n  constructor(\n    public readonly client: ReturnType<typeof useApolloClient>,\n    public readonly query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n    previous?: InternalState<TData, TVariables>\n  ) {\n    verifyDocumentType(query, DocumentType.Query);\n\n    // Reuse previousData from previous InternalState (if any) to provide\n    // continuity of previousData even if/when the query or client changes.\n    const previousResult = previous && previous.result;\n    const previousData = previousResult && previousResult.data;\n    if (previousData) {\n      this.previousData = previousData;\n    }\n  }\n\n  /**\n   * Forces an update using local component state.\n   * As this is not batched with `useSyncExternalStore` updates,\n   * this is only used as a fallback if the `useSyncExternalStore` \"force update\"\n   * method is not registered at the moment.\n   * See https://github.com/facebook/react/issues/25191\n   *  */\n  forceUpdateState() {\n    // Replaced (in useInternalState) with a method that triggers an update.\n    invariant.warn(\n      \"Calling default no-op implementation of InternalState#forceUpdate\"\n    );\n  }\n\n  /**\n   * Will be overwritten by the `useSyncExternalStore` \"force update\" method\n   * whenever it is available and reset to `forceUpdateState` when it isn't.\n   */\n  forceUpdate = () => this.forceUpdateState();\n\n  executeQuery(\n    options: QueryHookOptions<TData, TVariables> & {\n      query?: DocumentNode;\n    }\n  ) {\n    if (options.query) {\n      Object.assign(this, { query: options.query });\n    }\n\n    this.watchQueryOptions = this.createWatchQueryOptions(\n      (this.queryHookOptions = options)\n    );\n\n    const concast = this.observable.reobserveAsConcast(\n      this.getObsQueryOptions()\n    );\n\n    // Make sure getCurrentResult returns a fresh ApolloQueryResult<TData>,\n    // but save the current data as this.previousData, just like setResult\n    // usually does.\n    this.previousData = this.result?.data || this.previousData;\n    this.result = void 0;\n    this.forceUpdate();\n\n    return new Promise<QueryResult<TData, TVariables>>((resolve) => {\n      let result: ApolloQueryResult<TData>;\n\n      // Subscribe to the concast independently of the ObservableQuery in case\n      // the component gets unmounted before the promise resolves. This prevents\n      // the concast from terminating early and resolving with `undefined` when\n      // there are no more subscribers for the concast.\n      concast.subscribe({\n        next: (value) => {\n          result = value;\n        },\n        error: () => {\n          resolve(this.toQueryResult(this.observable.getCurrentResult()));\n        },\n        complete: () => {\n          resolve(this.toQueryResult(result));\n        },\n      });\n    });\n  }\n\n  // Methods beginning with use- should be called according to the standard\n  // rules of React hooks: only at the top level of the calling function, and\n  // without any dynamic conditional logic.\n  useQuery(options: QueryHookOptions<TData, TVariables>) {\n    // The renderPromises field gets initialized here in the useQuery method, at\n    // the beginning of everything (for a given component rendering, at least),\n    // so we can safely use this.renderPromises in other/later InternalState\n    // methods without worrying it might be uninitialized. Even after\n    // initialization, this.renderPromises is usually undefined (unless SSR is\n    // happening), but that's fine as long as it has been initialized that way,\n    // rather than left uninitialized.\n    this.renderPromises = React.useContext(getApolloContext()).renderPromises;\n\n    this.useOptions(options);\n\n    const obsQuery = this.useObservableQuery();\n\n    const result = useSyncExternalStore(\n      React.useCallback(\n        (handleStoreChange) => {\n          if (this.renderPromises) {\n            return () => {};\n          }\n\n          this.forceUpdate = handleStoreChange;\n\n          const onNext = () => {\n            const previousResult = this.result;\n            // We use `getCurrentResult()` instead of the onNext argument because\n            // the values differ slightly. Specifically, loading results will have\n            // an empty object for data instead of `undefined` for some reason.\n            const result = obsQuery.getCurrentResult();\n            // Make sure we're not attempting to re-render similar results\n            if (\n              previousResult &&\n              previousResult.loading === result.loading &&\n              previousResult.networkStatus === result.networkStatus &&\n              equal(previousResult.data, result.data)\n            ) {\n              return;\n            }\n\n            this.setResult(result);\n          };\n\n          const onError = (error: Error) => {\n            subscription.unsubscribe();\n            subscription = obsQuery.resubscribeAfterError(onNext, onError);\n\n            if (!hasOwnProperty.call(error, \"graphQLErrors\")) {\n              // The error is not a GraphQL error\n              throw error;\n            }\n\n            const previousResult = this.result;\n            if (\n              !previousResult ||\n              (previousResult && previousResult.loading) ||\n              !equal(error, previousResult.error)\n            ) {\n              this.setResult({\n                data: (previousResult && previousResult.data) as TData,\n                error: error as ApolloError,\n                loading: false,\n                networkStatus: NetworkStatus.error,\n              });\n            }\n          };\n\n          let subscription = obsQuery.subscribe(onNext, onError);\n\n          // Do the \"unsubscribe\" with a short delay.\n          // This way, an existing subscription can be reused without an additional\n          // request if \"unsubscribe\"  and \"resubscribe\" to the same ObservableQuery\n          // happen in very fast succession.\n          return () => {\n            setTimeout(() => subscription.unsubscribe());\n            this.forceUpdate = () => this.forceUpdateState();\n          };\n        },\n        [\n          // We memoize the subscribe function using useCallback and the following\n          // dependency keys, because the subscribe function reference is all that\n          // useSyncExternalStore uses internally as a dependency key for the\n          // useEffect ultimately responsible for the subscription, so we are\n          // effectively passing this dependency array to that useEffect buried\n          // inside useSyncExternalStore, as desired.\n          obsQuery,\n          this.renderPromises,\n          this.client.disableNetworkFetches,\n        ]\n      ),\n\n      () => this.getCurrentResult(),\n      () => this.getCurrentResult()\n    );\n\n    // TODO Remove this method when we remove support for options.partialRefetch.\n    this.unsafeHandlePartialRefetch(result);\n\n    return this.toQueryResult(result);\n  }\n\n  // These members (except for renderPromises) are all populated by the\n  // useOptions method, which is called unconditionally at the beginning of the\n  // useQuery method, so we can safely use these members in other/later methods\n  // without worrying they might be uninitialized.\n  private renderPromises: ApolloContextValue[\"renderPromises\"];\n  private queryHookOptions!: QueryHookOptions<TData, TVariables>;\n  private watchQueryOptions!: WatchQueryOptions<TVariables, TData>;\n\n  private useOptions(options: QueryHookOptions<TData, TVariables>) {\n    const watchQueryOptions = this.createWatchQueryOptions(\n      (this.queryHookOptions = options)\n    );\n\n    // Update this.watchQueryOptions, but only when they have changed, which\n    // allows us to depend on the referential stability of\n    // this.watchQueryOptions elsewhere.\n    const currentWatchQueryOptions = this.watchQueryOptions;\n\n    if (!equal(watchQueryOptions, currentWatchQueryOptions)) {\n      this.watchQueryOptions = watchQueryOptions;\n\n      if (currentWatchQueryOptions && this.observable) {\n        // Though it might be tempting to postpone this reobserve call to the\n        // useEffect block, we need getCurrentResult to return an appropriate\n        // loading:true result synchronously (later within the same call to\n        // useQuery). Since we already have this.observable here (not true for\n        // the very first call to useQuery), we are not initiating any new\n        // subscriptions, though it does feel less than ideal that reobserve\n        // (potentially) kicks off a network request (for example, when the\n        // variables have changed), which is technically a side-effect.\n        this.observable.reobserve(this.getObsQueryOptions());\n\n        // Make sure getCurrentResult returns a fresh ApolloQueryResult<TData>,\n        // but save the current data as this.previousData, just like setResult\n        // usually does.\n        this.previousData = this.result?.data || this.previousData;\n        this.result = void 0;\n      }\n    }\n\n    // Make sure state.onCompleted and state.onError always reflect the latest\n    // options.onCompleted and options.onError callbacks provided to useQuery,\n    // since those functions are often recreated every time useQuery is called.\n    // Like the forceUpdate method, the versions of these methods inherited from\n    // InternalState.prototype are empty no-ops, but we can override them on the\n    // base state object (without modifying the prototype).\n    this.onCompleted =\n      options.onCompleted || InternalState.prototype.onCompleted;\n    this.onError = options.onError || InternalState.prototype.onError;\n\n    if (\n      (this.renderPromises || this.client.disableNetworkFetches) &&\n      this.queryHookOptions.ssr === false &&\n      !this.queryHookOptions.skip\n    ) {\n      // If SSR has been explicitly disabled, and this function has been called\n      // on the server side, return the default loading state.\n      this.result = this.ssrDisabledResult;\n    } else if (\n      this.queryHookOptions.skip ||\n      this.watchQueryOptions.fetchPolicy === \"standby\"\n    ) {\n      // When skipping a query (ie. we're not querying for data but still want to\n      // render children), make sure the `data` is cleared out and `loading` is\n      // set to `false` (since we aren't loading anything).\n      //\n      // NOTE: We no longer think this is the correct behavior. Skipping should\n      // not automatically set `data` to `undefined`, but instead leave the\n      // previous data in place. In other words, skipping should not mandate that\n      // previously received data is all of a sudden removed. Unfortunately,\n      // changing this is breaking, so we'll have to wait until Apollo Client 4.0\n      // to address this.\n      this.result = this.skipStandbyResult;\n    } else if (\n      this.result === this.ssrDisabledResult ||\n      this.result === this.skipStandbyResult\n    ) {\n      this.result = void 0;\n    }\n  }\n\n  private getObsQueryOptions(): WatchQueryOptions<TVariables, TData> {\n    const toMerge: Array<Partial<WatchQueryOptions<TVariables, TData>>> = [];\n\n    const globalDefaults = this.client.defaultOptions.watchQuery;\n    if (globalDefaults) toMerge.push(globalDefaults);\n\n    if (this.queryHookOptions.defaultOptions) {\n      toMerge.push(this.queryHookOptions.defaultOptions);\n    }\n\n    // We use compact rather than mergeOptions for this part of the merge,\n    // because we want watchQueryOptions.variables (if defined) to replace\n    // this.observable.options.variables whole. This replacement allows\n    // removing variables by removing them from the variables input to\n    // useQuery. If the variables were always merged together (rather than\n    // replaced), there would be no way to remove existing variables.\n    // However, the variables from options.defaultOptions and globalDefaults\n    // (if provided) should be merged, to ensure individual defaulted\n    // variables always have values, if not otherwise defined in\n    // observable.options or watchQueryOptions.\n    toMerge.push(\n      compact(\n        this.observable && this.observable.options,\n        this.watchQueryOptions\n      )\n    );\n\n    return toMerge.reduce(mergeOptions) as WatchQueryOptions<TVariables, TData>;\n  }\n\n  private ssrDisabledResult = maybeDeepFreeze({\n    loading: true,\n    data: void 0 as unknown as TData,\n    error: void 0,\n    networkStatus: NetworkStatus.loading,\n  });\n\n  private skipStandbyResult = maybeDeepFreeze({\n    loading: false,\n    data: void 0 as unknown as TData,\n    error: void 0,\n    networkStatus: NetworkStatus.ready,\n  });\n\n  // A function to massage options before passing them to ObservableQuery.\n  private createWatchQueryOptions({\n    skip,\n    ssr,\n    onCompleted,\n    onError,\n    defaultOptions,\n    // The above options are useQuery-specific, so this ...otherOptions spread\n    // makes otherOptions almost a WatchQueryOptions object, except for the\n    // query property that we add below.\n    ...otherOptions\n  }: QueryHookOptions<TData, TVariables> = {}): WatchQueryOptions<\n    TVariables,\n    TData\n  > {\n    // This Object.assign is safe because otherOptions is a fresh ...rest object\n    // that did not exist until just now, so modifications are still allowed.\n    const watchQueryOptions: WatchQueryOptions<TVariables, TData> =\n      Object.assign(otherOptions, { query: this.query });\n\n    if (\n      this.renderPromises &&\n      (watchQueryOptions.fetchPolicy === \"network-only\" ||\n        watchQueryOptions.fetchPolicy === \"cache-and-network\")\n    ) {\n      // this behavior was added to react-apollo without explanation in this PR\n      // https://github.com/apollographql/react-apollo/pull/1579\n      watchQueryOptions.fetchPolicy = \"cache-first\";\n    }\n\n    if (!watchQueryOptions.variables) {\n      watchQueryOptions.variables = {} as TVariables;\n    }\n\n    if (skip) {\n      const {\n        fetchPolicy = this.getDefaultFetchPolicy(),\n        initialFetchPolicy = fetchPolicy,\n      } = watchQueryOptions;\n\n      // When skipping, we set watchQueryOptions.fetchPolicy initially to\n      // \"standby\", but we also need/want to preserve the initial non-standby\n      // fetchPolicy that would have been used if not skipping.\n      Object.assign(watchQueryOptions, {\n        initialFetchPolicy,\n        fetchPolicy: \"standby\",\n      });\n    } else if (!watchQueryOptions.fetchPolicy) {\n      watchQueryOptions.fetchPolicy =\n        this.observable?.options.initialFetchPolicy ||\n        this.getDefaultFetchPolicy();\n    }\n\n    return watchQueryOptions;\n  }\n\n  getDefaultFetchPolicy(): WatchQueryFetchPolicy {\n    return (\n      this.queryHookOptions.defaultOptions?.fetchPolicy ||\n      this.client.defaultOptions.watchQuery?.fetchPolicy ||\n      \"cache-first\"\n    );\n  }\n\n  // Defining these methods as no-ops on the prototype allows us to call\n  // state.onCompleted and/or state.onError without worrying about whether a\n  // callback was provided.\n  private onCompleted(data: TData) {}\n  private onError(error: ApolloError) {}\n\n  private observable!: ObservableQuery<TData, TVariables>;\n  private obsQueryFields!: Omit<\n    ObservableQueryFields<TData, TVariables>,\n    \"variables\"\n  >;\n\n  private useObservableQuery() {\n    // See if there is an existing observable that was used to fetch the same\n    // data and if so, use it instead since it will contain the proper queryId\n    // to fetch the result set. This is used during SSR.\n    const obsQuery = (this.observable =\n      (this.renderPromises &&\n        this.renderPromises.getSSRObservable(this.watchQueryOptions)) ||\n      this.observable || // Reuse this.observable if possible (and not SSR)\n      this.client.watchQuery(this.getObsQueryOptions()));\n\n    this.obsQueryFields = React.useMemo(\n      () => ({\n        refetch: obsQuery.refetch.bind(obsQuery),\n        reobserve: obsQuery.reobserve.bind(obsQuery),\n        fetchMore: obsQuery.fetchMore.bind(obsQuery),\n        updateQuery: obsQuery.updateQuery.bind(obsQuery),\n        startPolling: obsQuery.startPolling.bind(obsQuery),\n        stopPolling: obsQuery.stopPolling.bind(obsQuery),\n        subscribeToMore: obsQuery.subscribeToMore.bind(obsQuery),\n      }),\n      [obsQuery]\n    );\n\n    const ssrAllowed = !(\n      this.queryHookOptions.ssr === false || this.queryHookOptions.skip\n    );\n\n    if (this.renderPromises && ssrAllowed) {\n      this.renderPromises.registerSSRObservable(obsQuery);\n\n      if (obsQuery.getCurrentResult().loading) {\n        // TODO: This is a legacy API which could probably be cleaned up\n        this.renderPromises.addObservableQueryPromise(obsQuery);\n      }\n    }\n\n    return obsQuery;\n  }\n\n  // These members are populated by getCurrentResult and setResult, and it's\n  // okay/normal for them to be initially undefined.\n  private result: undefined | ApolloQueryResult<TData>;\n  private previousData: undefined | TData;\n\n  private setResult(nextResult: ApolloQueryResult<TData>) {\n    const previousResult = this.result;\n    if (previousResult && previousResult.data) {\n      this.previousData = previousResult.data;\n    }\n    this.result = nextResult;\n    // Calling state.setResult always triggers an update, though some call sites\n    // perform additional equality checks before committing to an update.\n    this.forceUpdate();\n    this.handleErrorOrCompleted(nextResult, previousResult);\n  }\n\n  private handleErrorOrCompleted(\n    result: ApolloQueryResult<TData>,\n    previousResult?: ApolloQueryResult<TData>\n  ) {\n    if (!result.loading) {\n      const error = this.toApolloError(result);\n\n      // wait a tick in case we are in the middle of rendering a component\n      Promise.resolve()\n        .then(() => {\n          if (error) {\n            this.onError(error);\n          } else if (\n            result.data &&\n            previousResult?.networkStatus !== result.networkStatus &&\n            result.networkStatus === NetworkStatus.ready\n          ) {\n            this.onCompleted(result.data);\n          }\n        })\n        .catch((error) => {\n          invariant.warn(error);\n        });\n    }\n  }\n\n  private toApolloError(\n    result: ApolloQueryResult<TData>\n  ): ApolloError | undefined {\n    return isNonEmptyArray(result.errors) ?\n        new ApolloError({ graphQLErrors: result.errors })\n      : result.error;\n  }\n\n  private getCurrentResult(): ApolloQueryResult<TData> {\n    // Using this.result as a cache ensures getCurrentResult continues returning\n    // the same (===) result object, unless state.setResult has been called, or\n    // we're doing server rendering and therefore override the result below.\n    if (!this.result) {\n      this.handleErrorOrCompleted(\n        (this.result = this.observable.getCurrentResult())\n      );\n    }\n    return this.result;\n  }\n\n  // This cache allows the referential stability of this.result (as returned by\n  // getCurrentResult) to translate into referential stability of the resulting\n  // QueryResult object returned by toQueryResult.\n  private toQueryResultCache = new (canUseWeakMap ? WeakMap : Map)<\n    ApolloQueryResult<TData>,\n    QueryResult<TData, TVariables>\n  >();\n\n  toQueryResult(\n    result: ApolloQueryResult<TData>\n  ): QueryResult<TData, TVariables> {\n    let queryResult = this.toQueryResultCache.get(result);\n    if (queryResult) return queryResult;\n\n    const { data, partial, ...resultWithoutPartial } = result;\n    this.toQueryResultCache.set(\n      result,\n      (queryResult = {\n        data, // Ensure always defined, even if result.data is missing.\n        ...resultWithoutPartial,\n        ...this.obsQueryFields,\n        client: this.client,\n        observable: this.observable,\n        variables: this.observable.variables,\n        called: !this.queryHookOptions.skip,\n        previousData: this.previousData,\n      })\n    );\n\n    if (!queryResult.error && isNonEmptyArray(result.errors)) {\n      // Until a set naming convention for networkError and graphQLErrors is\n      // decided upon, we map errors (graphQLErrors) to the error options.\n      // TODO: Is it possible for both result.error and result.errors to be\n      // defined here?\n      queryResult.error = new ApolloError({ graphQLErrors: result.errors });\n    }\n\n    return queryResult;\n  }\n\n  private unsafeHandlePartialRefetch(result: ApolloQueryResult<TData>) {\n    // WARNING: SIDE-EFFECTS IN THE RENDER FUNCTION\n    //\n    // TODO: This code should be removed when the partialRefetch option is\n    // removed. I was unable to get this hook to behave reasonably in certain\n    // edge cases when this block was put in an effect.\n    if (\n      result.partial &&\n      this.queryHookOptions.partialRefetch &&\n      !result.loading &&\n      (!result.data || Object.keys(result.data).length === 0) &&\n      this.observable.options.fetchPolicy !== \"cache-only\"\n    ) {\n      Object.assign(result, {\n        loading: true,\n        networkStatus: NetworkStatus.refetch,\n      });\n      this.observable.refetch();\n    }\n  }\n}\n", "import { invariant } from \"../../utilities/globals/index.js\";\nimport * as React from \"rehackt\";\n\nimport { canUseLayoutEffect } from \"../../utilities/index.js\";\n\nlet didWarnUncachedGetSnapshot = false;\n\ntype RealUseSESHookType =\n  // This import depends only on the @types/use-sync-external-store package, not\n  // the actual use-sync-external-store package, which is not installed. It\n  // might be nice to get this type from React 18, but it still needs to work\n  // when only React 17 or earlier is installed.\n  typeof import(\"use-sync-external-store\").useSyncExternalStore;\n\n// Prevent webpack from complaining about our feature detection of the\n// useSyncExternalStore property of the React namespace, which is expected not\n// to exist when using React 17 and earlier, and that's fine.\nconst uSESKey = \"useSyncExternalStore\" as keyof typeof React;\nconst realHook = React[uSESKey] as RealUseSESHookType | undefined;\n\n// Adapted from https://www.npmjs.com/package/use-sync-external-store, with\n// Apollo Client deviations called out by \"// DEVIATION ...\" comments.\n\n// When/if React.useSyncExternalStore is defined, delegate fully to it.\nexport const useSyncExternalStore: RealUseSESHookType =\n  realHook ||\n  ((subscribe, getSnapshot, getServerSnapshot) => {\n    // Read the current snapshot from the store on every render. Again, this\n    // breaks the rules of React, and only works here because of specific\n    // implementation details, most importantly that updates are\n    // always synchronous.\n    const value = getSnapshot();\n    if (\n      // DEVIATION: Using __DEV__\n      __DEV__ &&\n      !didWarnUncachedGetSnapshot &&\n      // DEVIATION: Not using Object.is because we know our snapshots will never\n      // be exotic primitive values like NaN, which is !== itself.\n      value !== getSnapshot()\n    ) {\n      didWarnUncachedGetSnapshot = true;\n      // DEVIATION: Using invariant.error instead of console.error directly.\n      invariant.error(\n        \"The result of getSnapshot should be cached to avoid an infinite loop\"\n      );\n    }\n\n    // Because updates are synchronous, we don't queue them. Instead we force a\n    // re-render whenever the subscribed state changes by updating an some\n    // arbitrary useState hook. Then, during render, we call getSnapshot to read\n    // the current value.\n    //\n    // Because we don't actually use the state returned by the useState hook, we\n    // can save a bit of memory by storing other stuff in that slot.\n    //\n    // To implement the early bailout, we need to track some things on a mutable\n    // object. Usually, we would put that in a useRef hook, but we can stash it in\n    // our useState hook instead.\n    //\n    // To force a re-render, we call forceUpdate({inst}). That works because the\n    // new object always fails an equality check.\n    const [{ inst }, forceUpdate] = React.useState({\n      inst: { value, getSnapshot },\n    });\n\n    // Track the latest getSnapshot function with a ref. This needs to be updated\n    // in the layout phase so we can access it during the tearing check that\n    // happens on subscribe.\n    if (canUseLayoutEffect) {\n      // DEVIATION: We avoid calling useLayoutEffect when !canUseLayoutEffect,\n      // which may seem like a conditional hook, but this code ends up behaving\n      // unconditionally (one way or the other) because canUseLayoutEffect is\n      // constant.\n      React.useLayoutEffect(() => {\n        Object.assign(inst, { value, getSnapshot });\n        // Whenever getSnapshot or subscribe changes, we need to check in the\n        // commit phase if there was an interleaved mutation. In concurrent mode\n        // this can happen all the time, but even in synchronous mode, an earlier\n        // effect may have mutated the store.\n        if (checkIfSnapshotChanged(inst)) {\n          // Force a re-render.\n          forceUpdate({ inst });\n        }\n      }, [subscribe, value, getSnapshot]);\n    } else {\n      Object.assign(inst, { value, getSnapshot });\n    }\n\n    React.useEffect(() => {\n      // Check for changes right before subscribing. Subsequent changes will be\n      // detected in the subscription handler.\n      if (checkIfSnapshotChanged(inst)) {\n        // Force a re-render.\n        forceUpdate({ inst });\n      }\n\n      // Subscribe to the store and return a clean-up function.\n      return subscribe(function handleStoreChange() {\n        // TODO: Because there is no cross-renderer API for batching updates, it's\n        // up to the consumer of this library to wrap their subscription event\n        // with unstable_batchedUpdates. Should we try to detect when this isn't\n        // the case and print a warning in development?\n\n        // The store changed. Check if the snapshot changed since the last time we\n        // read from the store.\n        if (checkIfSnapshotChanged(inst)) {\n          // Force a re-render.\n          forceUpdate({ inst });\n        }\n      });\n    }, [subscribe]);\n\n    return value;\n  });\n\nfunction checkIfSnapshotChanged<Snapshot>({\n  value,\n  getSnapshot,\n}: {\n  value: Snapshot;\n  getSnapshot: () => Snapshot;\n}): boolean {\n  try {\n    return value !== getSnapshot();\n  } catch {\n    return true;\n  }\n}\n", "import type {\n  useQuery,\n  useSuspenseQuery,\n  useBackgroundQuery,\n  useReadQuery,\n  useFragment,\n} from \"../index.js\";\nimport type { QueryManager } from \"../../../core/QueryManager.js\";\nimport type { ApolloClient } from \"../../../core/ApolloClient.js\";\nimport type { ObservableQuery } from \"../../../core/ObservableQuery.js\";\n\nconst wrapperSymbol = Symbol.for(\"apollo.hook.wrappers\");\n\ninterface WrappableHooks {\n  useQuery: typeof useQuery;\n  useSuspenseQuery: typeof useSuspenseQuery;\n  useBackgroundQuery: typeof useBackgroundQuery;\n  useReadQuery: typeof useReadQuery;\n  useFragment: typeof useFragment;\n}\n\n/**\n * @internal\n * Can be used to correctly type the [Symbol.for(\"apollo.hook.wrappers\")] property of\n * `QueryManager`, to override/wrap hook functionality.\n */\nexport type HookWrappers = {\n  [K in keyof WrappableHooks]?: (\n    originalHook: WrappableHooks[K]\n  ) => WrappableHooks[K];\n};\n\ninterface QueryManagerWithWrappers<T> extends QueryManager<T> {\n  [wrapperSymbol]?: HookWrappers;\n}\n\n/**\n * @internal\n *\n * Makes an Apollo Client hook \"wrappable\".\n * That means that the Apollo Client instance can expose a \"wrapper\" that will be\n * used to wrap the original hook implementation with additional logic.\n * @example\n * ```tsx\n * // this is already done in `@apollo/client` for all wrappable hooks (see `WrappableHooks`)\n * // following this pattern\n * function useQuery() {\n *   return wrapHook('useQuery', _useQuery, options.client)(query, options);\n * }\n * function _useQuery(query, options) {\n *   // original implementation\n * }\n *\n * // this is what a library like `@apollo/client-react-streaming` would do\n * class ApolloClientWithStreaming extends ApolloClient {\n *   constructor(options) {\n *     super(options);\n *     this.queryManager[Symbol.for(\"apollo.hook.wrappers\")] = {\n *       useQuery: (original) => (query, options) => {\n *         console.log(\"useQuery was called with options\", options);\n *         return original(query, options);\n *       }\n *     }\n *   }\n * }\n *\n * // this will now log the options and then call the original `useQuery`\n * const client = new ApolloClientWithStreaming({ ... });\n * useQuery(query, { client });\n * ```\n */\nexport function wrapHook<Hook extends (...args: any[]) => any>(\n  hookName: keyof WrappableHooks,\n  useHook: Hook,\n  clientOrObsQuery: ObservableQuery<any> | ApolloClient<any>\n): Hook {\n  const queryManager = (\n    clientOrObsQuery as unknown as {\n      // both `ApolloClient` and `ObservableQuery` have a `queryManager` property\n      // but they're both `private`, so we have to cast around for a bit here.\n      queryManager: QueryManagerWithWrappers<any>;\n    }\n  )[\"queryManager\"];\n  const wrappers = queryManager && queryManager[wrapperSymbol];\n  const wrapper: undefined | ((wrap: Hook) => Hook) =\n    wrappers && (wrappers[hookName] as any);\n  return wrapper ? wrapper(useHook) : useHook;\n}\n"],
  "mappings": "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",
  "names": ["React", "InternalState", "result"]
}
